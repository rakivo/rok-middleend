// @Refactor
#![allow(
    clippy::uninlined_format_args,
    clippy::single_char_add_str,
    clippy::format_push_string
)]

use crate::bytecode::Opcode;
use crate::lower::LoweredSsaFunc;

use std::fmt::{self, Write};

/// A bytecode reader that provides methods to read different data types
pub struct BytecodeReader<'a> {
    data: &'a [u8],
    offset: usize,
}

impl<'a> BytecodeReader<'a> {
    #[must_use]
    pub fn new(data: &'a [u8]) -> Self {
        Self { data, offset: 0 }
    }

    pub fn read_u8(&mut self) -> u8 {
        let val = self.data[self.offset];
        self.offset += 1;
        val
    }

    pub fn read_i8(&mut self) -> i8 {
        self.read_u8() as i8
    }

    pub fn read_u16(&mut self) -> u16 {
        let bytes = [self.data[self.offset], self.data[self.offset + 1]];
        self.offset += 2;
        u16::from_le_bytes(bytes)
    }

    pub fn read_i16(&mut self) -> i16 {
        self.read_u16() as i16
    }

    pub fn read_u32(&mut self) -> u32 {
        let bytes = [
            self.data[self.offset],
            self.data[self.offset + 1],
            self.data[self.offset + 2],
            self.data[self.offset + 3],
        ];
        self.offset += 4;
        u32::from_le_bytes(bytes)
    }

    pub fn read_i32(&mut self) -> i32 {
        self.read_u32() as i32
    }

    pub fn read_u64(&mut self) -> u64 {
        let bytes = [
            self.data[self.offset],
            self.data[self.offset + 1],
            self.data[self.offset + 2],
            self.data[self.offset + 3],
            self.data[self.offset + 4],
            self.data[self.offset + 5],
            self.data[self.offset + 6],
            self.data[self.offset + 7],
        ];
        self.offset += 8;
        u64::from_le_bytes(bytes)
    }

    pub fn read_i64(&mut self) -> i64 {
        self.read_u64() as i64
    }

    pub fn read_f32(&mut self) -> f32 {
        f32::from_bits(self.read_u32())
    }

    pub fn read_f64(&mut self) -> f64 {
        f64::from_bits(self.read_u64())
    }

    #[must_use]
    pub fn position(&self) -> usize {
        self.offset
    }

    #[must_use]
    pub fn remaining(&self) -> usize {
        self.data.len() - self.offset
    }
}

// This should match your actual Opcode enum generated by define_opcodes!
// The discriminants are specified in the macro call

impl Opcode {
    /// Converts a u8 discriminant to an Opcode variant
    /// Returns None if the discriminant doesn't match any opcode
    #[must_use]
    pub fn from_u8(val: u8) -> Option<Self> {
        // This uses the discriminants from define_opcodes! macro
        match val {
            0 => Some(Opcode::IConst8),
            1 => Some(Opcode::IConst16),
            2 => Some(Opcode::IConst32),
            3 => Some(Opcode::IConst64),
            4 => Some(Opcode::FConst32),
            5 => Some(Opcode::FConst64),
            10 => Some(Opcode::IAdd),
            11 => Some(Opcode::ISub),
            12 => Some(Opcode::IMul),
            13 => Some(Opcode::IDiv),
            14 => Some(Opcode::And),
            15 => Some(Opcode::Or),
            16 => Some(Opcode::Xor),
            17 => Some(Opcode::Ushr),
            18 => Some(Opcode::Ishl),
            19 => Some(Opcode::Band),
            20 => Some(Opcode::Bor),
            22 => Some(Opcode::FAdd),
            23 => Some(Opcode::FSub),
            24 => Some(Opcode::FMul),
            25 => Some(Opcode::FDiv),
            26 => Some(Opcode::Jump16),
            27 => Some(Opcode::BranchIf16),
            28 => Some(Opcode::Return),
            29 => Some(Opcode::Call),
            30 => Some(Opcode::Ireduce),
            31 => Some(Opcode::Uextend),
            32 => Some(Opcode::Sextend),
            33 => Some(Opcode::Bitcast),
            40 => Some(Opcode::Load8),
            41 => Some(Opcode::Load16),
            42 => Some(Opcode::Load32),
            43 => Some(Opcode::Load64),
            44 => Some(Opcode::Store8),
            45 => Some(Opcode::Store16),
            47 => Some(Opcode::Store32),
            50 => Some(Opcode::Mov),
            60 => Some(Opcode::FrameSetup),
            61 => Some(Opcode::FrameTeardown),
            62 => Some(Opcode::SpAdd),
            63 => Some(Opcode::SpSub),
            67 => Some(Opcode::FPromote),
            69 => Some(Opcode::FNeg),
            70 => Some(Opcode::FpLoad8),
            71 => Some(Opcode::FpLoad16),
            72 => Some(Opcode::FpLoad32),
            73 => Some(Opcode::FpLoad64),
            74 => Some(Opcode::FpStore8),
            75 => Some(Opcode::FpStore16),
            76 => Some(Opcode::FpStore32),
            77 => Some(Opcode::FpStore64),
            80 => Some(Opcode::SpLoad8),
            81 => Some(Opcode::SpLoad16),
            82 => Some(Opcode::SpLoad32),
            83 => Some(Opcode::SpLoad64),
            84 => Some(Opcode::SpStore8),
            85 => Some(Opcode::SpStore16),
            86 => Some(Opcode::SpStore32),
            87 => Some(Opcode::SpStore64),
            90 => Some(Opcode::FpAddr),
            91 => Some(Opcode::SpAddr),
            95 => Some(Opcode::LoadDataAddr),
            96 => Some(Opcode::IEq),
            97 => Some(Opcode::INe),
            98 => Some(Opcode::ISGt),
            99 => Some(Opcode::ISGe),
            100 => Some(Opcode::ISLt),
            101 => Some(Opcode::ISLe),
            102 => Some(Opcode::IUGt),
            103 => Some(Opcode::IUGe),
            104 => Some(Opcode::IULt),
            105 => Some(Opcode::IULe),
            128 => Some(Opcode::Nop),
            135 => Some(Opcode::CallHook),
            136 => Some(Opcode::CallExt),
            200 => Some(Opcode::FDemote),
            201 => Some(Opcode::FloatToSInt),
            202 => Some(Opcode::FloatToUInt),
            203 => Some(Opcode::SIntToFloat),
            204 => Some(Opcode::UIntToFloat),
            255 => Some(Opcode::Halt),
            _ => None,
        }
    }
}

/// Formats an instruction in assembly-like format with proper alignment
pub fn print_instruction(reader: &mut BytecodeReader, f: &mut impl Write) -> fmt::Result {
    if reader.remaining() == 0 {
        return write!(f, "<end of bytecode>");
    }

    let opcode_byte = reader.read_u8();
    let opcode = unsafe { core::mem::transmute(opcode_byte) };

    match opcode {
        // Constants
        Opcode::IConst8 => {
            let dst = reader.read_u32();
            let val = reader.read_i8();
            write!(f, "{:<16} r{}, {}", "iconst.i8", dst, val)
        }
        Opcode::IConst16 => {
            let dst = reader.read_u32();
            let val = reader.read_i16();
            write!(f, "{:<16} r{}, {}", "iconst.i16", dst, val)
        }
        Opcode::IConst32 => {
            let dst = reader.read_u32();
            let val = reader.read_i32();
            write!(f, "{:<16} r{}, {}", "iconst.i32", dst, val)
        }
        Opcode::IConst64 => {
            let dst = reader.read_u32();
            let val = reader.read_i64();
            write!(f, "{:<16} r{}, {}", "iconst.i64", dst, val)
        }
        Opcode::FConst32 => {
            let dst = reader.read_u32();
            let val = reader.read_f32();
            write!(f, "{:<16} r{}, {}", "fconst.f32", dst, val)
        }
        Opcode::FConst64 => {
            let dst = reader.read_u32();
            let val = reader.read_f64();
            write!(f, "{:<16} r{}, {}", "fconst.f64", dst, val)
        }

        // Integer Arithmetic
        Opcode::IAdd => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "iadd", dst, a, b)
        }
        Opcode::ISub => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "isub", dst, a, b)
        }
        Opcode::IMul => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "imul", dst, a, b)
        }
        Opcode::IDiv => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "idiv", dst, a, b)
        }

        // Logical Operations
        Opcode::And => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "and", dst, a, b)
        }
        Opcode::Or => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "or", dst, a, b)
        }
        Opcode::Xor => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "xor", dst, a, b)
        }

        // Shift Operations
        Opcode::Ushr => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "ushr", dst, a, b)
        }
        Opcode::Ishl => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "ishl", dst, a, b)
        }

        // Bitwise Operations
        Opcode::Band => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "band", dst, a, b)
        }
        Opcode::Bor => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "bor", dst, a, b)
        }

        // Float Arithmetic
        Opcode::FAdd => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "fadd", dst, a, b)
        }
        Opcode::FSub => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "fsub", dst, a, b)
        }
        Opcode::FMul => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "fmul", dst, a, b)
        }
        Opcode::FDiv => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "fdiv", dst, a, b)
        }

        // Control Flow
        Opcode::Jump16 => {
            let offset = reader.read_i16();

            // jump_with_args writes: count (u8) followed by pairs of (arg, param) as u32
            let num_args = reader.read_u8();
            let mut moves = Vec::new();
            for _ in 0..num_args {
                let arg = reader.read_u32();
                let param = reader.read_u32();
                moves.push((arg, param));
            }

            if moves.is_empty() {
                write!(f, "{:<16} {:05X}", "jump", offset)
            } else {
                let moves_str = moves.iter()
                    .map(|(arg, param)| format!("r{} -> r{}", arg, param))
                    .collect::<Vec<_>>()
                    .join(", ");
                write!(f, "{:<16} {:05X} ({})", "jump", offset, moves_str)
            }
        }

        Opcode::BranchIf16 => {
            let cond = reader.read_u32();
            let true_offset = reader.read_i16();

            // jump_with_args for true branch
            let num_args_true = reader.read_u8();
            let mut moves_true = Vec::new();
            for _ in 0..num_args_true {
                let arg = reader.read_u32();
                let param = reader.read_u32();
                moves_true.push((arg, param));
            }

            let _jump_opcode = reader.read_u8();

            let false_offset = reader.read_i16();

            // jump_with_args for false branch
            let num_args_false = reader.read_u8();
            let mut moves_false = Vec::new();
            for _ in 0..num_args_false {
                let arg = reader.read_u32();
                let param = reader.read_u32();
                moves_false.push((arg, param));
            }

            let true_moves_str = if moves_true.is_empty() {
                String::new()
            } else {
                format!(" ({})", moves_true.iter()
                    .map(|(arg, param)| format!("r{} -> r{}", arg, param))
                    .collect::<Vec<_>>()
                    .join(", "))
            };

            let false_moves_str = if moves_false.is_empty() {
                String::new()
            } else {
                format!(" ({})", moves_false.iter()
                    .map(|(arg, param)| format!("r{} -> r{}", arg, param))
                    .collect::<Vec<_>>()
                    .join(", "))
            };

            write!(f, "{:<16} r{}, true:{:05X}{}, false:{:05X}{}",
                   "branchif", cond, true_offset, true_moves_str, false_offset, false_moves_str)
        }

        Opcode::Return => {
            // append_args writes: count (u8) followed by each arg (u32)
            let num_args = reader.read_u8();
            let mut args = Vec::new();
            for _ in 0..num_args {
                args.push(reader.read_u32());
            }

            if args.is_empty() {
                write!(f, "{:<16}", "return")
            } else {
                let args_str = args.iter()
                    .map(|a| format!("r{}", a))
                    .collect::<Vec<_>>()
                    .join(", ");
                write!(f, "{:<16} {}", "return", args_str)
            }
        }

        Opcode::Call => {
            let num_results = reader.read_u8();
            let mut results = Vec::new();
            for _ in 0..num_results {
                results.push(reader.read_u32());
            }
            let key = reader.read_u64();

            // Read arguments
            let num_args = reader.read_u8();
            let mut args = Vec::new();
            for _ in 0..num_args {
                args.push(reader.read_u32());
            }

            // Format output
            let args_str = if args.is_empty() {
                String::new()
            } else {
                format!("({})", args.iter()
                    .map(|a| format!("r{}", a))
                    .collect::<Vec<_>>()
                    .join(", "))
            };

            if results.is_empty() {
                write!(f, "{:<16} func_{:016x}{}", "call", key, args_str)
            } else if results.len() == 1 {
                write!(f, "{:<16} r{} = func_{:016x}{}", "call", results[0], key, args_str)
            } else {
                let results_str = results.iter()
                    .map(|r| format!("r{}", r))
                    .collect::<Vec<_>>()
                    .join(", ");
                write!(f, "{:<16} ({}) = func_{:016x}{}", "call", results_str, key, args_str)
            }
        }

        Opcode::CallHook => {
            let result = reader.read_u32();
            let hook_id = reader.read_u32();

            // Read arguments
            let num_args = reader.read_u8();
            let mut args = Vec::new();
            for _ in 0..num_args {
                args.push(reader.read_u32());
            }

            let args_str = if args.is_empty() {
                String::new()
            } else {
                format!("({})", args.iter()
                    .map(|a| format!("r{}", a))
                    .collect::<Vec<_>>()
                    .join(", "))
            };

            if result == u32::MAX {
                write!(f, "{:<16} hook_{}{}", "call.hook", hook_id, args_str)
            } else {
                write!(f, "{:<16} r{} = hook_{}{}", "call.hook", result, hook_id, args_str)
            }
        }

        Opcode::CallExt => {
            let num_results = reader.read_u8();
            let mut results = Vec::new();
            for _ in 0..num_results {
                results.push(reader.read_u32());
            }
            let key = reader.read_u64();

            // Read arguments
            let num_args = reader.read_u8();
            let mut args = Vec::new();
            for _ in 0..num_args {
                args.push(reader.read_u32());
            }

            // Format output
            let args_str = if args.is_empty() {
                String::new()
            } else {
                format!("({})", args.iter()
                    .map(|a| format!("r{}", a))
                    .collect::<Vec<_>>()
                    .join(", "))
            };

            if results.is_empty() {
                write!(f, "{:<16} extfunc_{:016x}{}", "call.ext", key, args_str)
            } else if results.len() == 1 {
                write!(f, "{:<16} r{} = extfunc_{:016x}{}", "call.ext", results[0], key, args_str)
            } else {
                let results_str = results.iter()
                    .map(|r| format!("r{}", r))
                    .collect::<Vec<_>>()
                    .join(", ");
                write!(f, "{:<16} ({}) = extfunc_{:016x}{}", "call.ext", results_str, key, args_str)
            }
        }

        // Type Conversions
        Opcode::Ireduce => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            let bits = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, i{}", "ireduce", dst, src, bits)
        }
        Opcode::Uextend => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            let from_bits = reader.read_u32();
            let to_bits = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, i{} -> i{}", "uextend", dst, src, from_bits, to_bits)
        }
        Opcode::Sextend => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "sextend", dst, src)
        }
        Opcode::Bitcast => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            let ty = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, i{}", "bitcast", dst, src, ty)
        }

        // Memory Operations - Load
        Opcode::Load8 => {
            let dst = reader.read_u32();
            let addr = reader.read_u32();
            write!(f, "{:<16} r{}, [r{}]", "load.i8", dst, addr)
        }
        Opcode::Load16 => {
            let dst = reader.read_u32();
            let addr = reader.read_u32();
            write!(f, "{:<16} r{}, [r{}]", "load.i16", dst, addr)
        }
        Opcode::Load32 => {
            let dst = reader.read_u32();
            let addr = reader.read_u32();
            write!(f, "{:<16} r{}, [r{}]", "load.i32", dst, addr)
        }
        Opcode::Load64 => {
            let dst = reader.read_u32();
            let addr = reader.read_u32();
            write!(f, "{:<16} r{}, [r{}]", "load.i64", dst, addr)
        }

        // Memory Operations - Store
        Opcode::Store8 => {
            let addr = reader.read_u32();
            let val = reader.read_u32();
            write!(f, "{:<16} [r{}], r{}", "store.i8", addr, val)
        }
        Opcode::Store16 => {
            let addr = reader.read_u32();
            let val = reader.read_u32();
            write!(f, "{:<16} [r{}], r{}", "store.i16", addr, val)
        }
        Opcode::Store32 | Opcode::Store64 => {
            let addr = reader.read_u32();
            let val = reader.read_u32();
            write!(f, "{:<16} [r{}], r{}", "store", addr, val)
        }

        // Stack Operations
        Opcode::Mov => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "mov", dst, src)
        }

        // Stack Frame Management
        Opcode::FrameSetup => {
            let size = reader.read_u32();
            write!(f, "{:<16} {}", "frame.setup", size)
        }
        Opcode::FrameTeardown => write!(f, "{:<16}", "frame.teardown"),
        Opcode::SpAdd => {
            let offset = reader.read_u32();
            write!(f, "{:<16} {}", "sp.add", offset)
        }
        Opcode::SpSub => {
            let offset = reader.read_u32();
            write!(f, "{:<16} {}", "sp.sub", offset)
        }

        // Float Conversions
        Opcode::FPromote => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "fpromote", dst, src)
        }
        Opcode::FDemote => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "fdemote", dst, src)
        }
        Opcode::FNeg => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "fneg", dst, src)
        }

        // Frame Pointer Operations - Load
        Opcode::FpLoad8 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [fp{:+}]", "load.i8", dst, offset)
        }
        Opcode::FpLoad16 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [fp{:+}]", "load.i16", dst, offset)
        }
        Opcode::FpLoad32 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [fp{:+}]", "load.i32", dst, offset)
        }
        Opcode::FpLoad64 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [fp{:+}]", "load.i64", dst, offset)
        }

        // Frame Pointer Operations - Store
        Opcode::FpStore8 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [fp{:+}], r{}", "store.i8", offset, src)
        }
        Opcode::FpStore16 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [fp{:+}], r{}", "store.i16", offset, src)
        }
        Opcode::FpStore32 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [fp{:+}], r{}", "store.i32", offset, src)
        }
        Opcode::FpStore64 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [fp{:+}], r{}", "store.i64", offset, src)
        }

        // Stack Pointer Operations - Load
        Opcode::SpLoad8 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [sp{:+}]", "load.i8", dst, offset)
        }
        Opcode::SpLoad16 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [sp{:+}]", "load.i16", dst, offset)
        }
        Opcode::SpLoad32 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [sp{:+}]", "load.i32", dst, offset)
        }
        Opcode::SpLoad64 => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, [sp{:+}]", "load.i64", dst, offset)
        }

        // Stack Pointer Operations - Store
        Opcode::SpStore8 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [sp{:+}], r{}", "store.i8", offset, src)
        }
        Opcode::SpStore16 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [sp{:+}], r{}", "store.i16", offset, src)
        }
        Opcode::SpStore32 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [sp{:+}], r{}", "store.i32", offset, src)
        }
        Opcode::SpStore64 => {
            let offset = reader.read_i32();
            let src = reader.read_u32();
            write!(f, "{:<16} [sp{:+}], r{}", "store.i64", offset, src)
        }

        // Address Calculation
        Opcode::FpAddr => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, fp{:+}", "addr", dst, offset)
        }
        Opcode::SpAddr => {
            let dst = reader.read_u32();
            let offset = reader.read_i32();
            write!(f, "{:<16} r{}, sp{:+}", "addr", dst, offset)
        }

        // Data Address
        Opcode::LoadDataAddr => {
            let dst = reader.read_u32();
            let data_id = reader.read_u32();
            write!(f, "{:<16} r{}, data_{}", "load.data.addr", dst, data_id)
        }

        // Integer Comparisons
        Opcode::IEq => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.eq", dst, a, b)
        }
        Opcode::INe => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.ne", dst, a, b)
        }
        Opcode::ISGt => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.sgt", dst, a, b)
        }
        Opcode::ISGe => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.sge", dst, a, b)
        }
        Opcode::ISLt => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.slt", dst, a, b)
        }
        Opcode::ISLe => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.sle", dst, a, b)
        }
        Opcode::IUGt => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.ugt", dst, a, b)
        }
        Opcode::IUGe => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.uge", dst, a, b)
        }
        Opcode::IULt => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.ult", dst, a, b)
        }
        Opcode::IULe => {
            let dst = reader.read_u32();
            let a = reader.read_u32();
            let b = reader.read_u32();
            write!(f, "{:<16} r{}, r{}, r{}", "icmp.ule", dst, a, b)
        }

        // Float-Int Conversions
        Opcode::FloatToSInt => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "fcvt.to.si", dst, src)
        }
        Opcode::FloatToUInt => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "fcvt.to.ui", dst, src)
        }
        Opcode::SIntToFloat => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "fcvt.from.si", dst, src)
        }
        Opcode::UIntToFloat => {
            let dst = reader.read_u32();
            let src = reader.read_u32();
            write!(f, "{:<16} r{}, r{}", "fcvt.from.ui", dst, src)
        }

        // Special Instructions
        Opcode::Nop => write!(f, "{:<16}", "nop"),
        Opcode::Halt => write!(f, "{:<16}", "halt"),
    }
}

/// Disassembles bytecode with optional metadata annotations in compiler assembly style
#[must_use]
pub fn disassemble(bytecode: &[u8], _lowered: Option<&LoweredSsaFunc>) -> String {
    let mut reader = BytecodeReader::new(bytecode);
    let mut output = String::new();
    #[allow(unused_mut, unused)]
    let mut curr_block: Option<crate::ssa::Block> = None;

    while reader.remaining() > 0 {
        let offset = reader.position();
        let offset_str = format!("{:05X}", offset);

        // Print metadata if available
        #[cfg(debug_assertions)]
        if let Some(lowered) = _lowered
        && let Some(crate::lower::LoInstMeta { pc, inst, size }) =
            lowered.context.pc_to_inst_meta.get(&offset)
        {
            use crate::entity::EntityRef;

            // Look up the block this instruction belongs to
            if let Some(&block) = lowered.context.func.layout.inst_blocks.get(inst)
            && Some(block) != curr_block
            {
                curr_block = Some(block);
                output.push_str("\n");
                output.push_str(&format!("{} ; block({})\n", offset_str, block.index()));
            }

            output.push_str("\n");
            output.push_str(&format!("{} ;\n", offset_str));
            output.push_str(&format!("{} ; original SSA instruction:\n", offset_str));
            output.push_str(&format!("{} ; {}\n", offset_str,
                lowered.context.func.pretty_print_inst(*inst)));

            if let Some(comment) = lowered.context.func.metadata.comments.get(inst) {
                output.push_str(&format!("{} ;\n", offset_str));
                output.push_str(&format!("{} ; comment:\n", offset_str));
                output.push_str(&format!("{} ; {}\n", offset_str, comment));
            }

            output.push_str(&format!("{} ;\n", offset_str));
            output.push_str(&format!("{} ;   pc={:?} inst_id={:?}, size={}\n",
                offset_str, pc, inst, size));
            output.push_str(&format!("{} ;\n", offset_str));
        }

        // Print the instruction
        output.push_str(&format!("{}   ", offset_str));

        let mut inst_buf = String::new();
        if print_instruction(&mut reader, &mut inst_buf).is_ok() {
            output.push_str(&inst_buf);
        } else {
            output.push_str("<error>");
        }

        output.push_str("\n");
    }

    output
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_print_iconst() {
        let bytecode = vec![0, 1, 0, 0, 0, 42]; // IConst8 r1, 42
        let result = disassemble(&bytecode, None);
        assert!(result.contains("iconst.i8"));
        assert!(result.contains("r1"));
        assert!(result.contains("42"));
    }

    #[test]
    fn test_print_iadd() {
        let bytecode = vec![10, 3, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0]; // IAdd r3, r1, r2
        let result = disassemble(&bytecode, None);
        assert!(result.contains("iadd"));
        assert!(result.contains("r3"));
        assert!(result.contains("r1"));
        assert!(result.contains("r2"));
    }

    #[test]
    fn test_call_with_multiple_results() {
        let mut bytecode = vec![29]; // Call opcode
        bytecode.push(2); // 2 results
        bytecode.extend_from_slice(&5u32.to_le_bytes()); // r5
        bytecode.extend_from_slice(&6u32.to_le_bytes()); // r6
        bytecode.extend_from_slice(&0x1234567890ABCDEFu64.to_le_bytes()); // function key

        let result = disassemble(&bytecode, None);
        assert!(result.contains("call"));
        assert!(result.contains("r5, r6"));
    }
}
